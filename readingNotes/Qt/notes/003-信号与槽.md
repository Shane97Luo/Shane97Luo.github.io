# 信号与槽机制(Signal & Slot)

在GUI用户界面中，当用户操作窗口部件时，需要其他窗口部件的响应或者能够激活其他的操作。在程序开发中，往往用回调（callback）机制来实现。

	回调，就是事先将一个回调函数(callbackfunction)指针传递给某一个处理过程，当这个处理过程得到执行时，回调预先定义好的回调函数以期实现激活其他处理过程的目的。

不同于回调函数机制，Qt提供了信号和槽。信号是一个特定的标识；一个槽就是一个函数，与一般的函数不同，槽函数既能够和信号关联，也能够像普通函数一样直接调用。当某个事件出现时，通过发送信号，可以将与之相关联的槽函数激活，即执行槽函数代码。在程序中，使用QObject::connect()函数来将某个信号和某个槽进行关联，而信号和槽之间的真正关联是由Qt的信号和槽机制来实现的。

## 连接方式

范例：

c++```
   //关闭窗口
   QPushButton * out = new QPushButton("close widget");
   QObject::connect(out,SIGNAL(clicked()),cornerWidget,SLOT(close()));
```

函数QObject::connect()将“关闭”按钮btn的clicked()信号同窗口pWidget的close()槽关联起来。QObject::connect()函数中，实参btn是发信号的源对象指针，实参pWidget是接受信号的目标对象指针;clicked()信号和close()槽已经分别由Qt的QPushButton类和QWidget类定义了，所以无需事先声明和定义就可以直接使用；SIGNAL()和SLOT()是Qt定义的两个宏，它们返回其参数的C风格字符串(const char*)。此处，程序使用了QObject对象的静态函数connect()，此外QObject类还提供了非静态形式的connect()函数。继承自QObject的Qt类都具有支持信号和槽的能力，并且可以在子类的实现代码中直接使用connect()函数。

##信号与槽的对应

* 一 对 一
* 一 对 多
* 多 对 一


```c++
private signals:

private slots:
   void showRet()
   ......

//按钮触发信号
connect(pushButton,SIGNAL(clicked()),this,SLOT(showRet()));
//行编辑器文本改变触发
connect(lineEdit,SIGNAL(textChanged(QString)),this,SLOT(showRet()));
```

一个信号和多个槽关联的情况下，当发出该信号的时候，与该信号关联的各个槽以任意的先后顺序立即执行（即槽函数的执行顺序是随机的，与槽关联的顺序没有关系）。信号和槽机制是完全独立于GUI事件循环的。此外，信号还可以和信号进行关联。当两个信号关联时，第一个信号的发出将会激活Qt发送第二个信号。

* Qt::DirectConnection，信号发送后立即传递给相关联的槽，只有槽函数执行完毕返回后，发送信号“emit<信号>”之后的代码才被执行。
* Qt::QueuedConnection，信号发送后排队，直到事件循环（event loop）有能力将它传递给槽；而不管槽函数有没有执行，发送信号“emit<信号>”之后的代码都会立即得到执行
* Qt::AutoConnection：如果信号和槽在同一个线程，信号发出后，槽函数将立即执行，等同于Qt::DirectConnection；如果信号和槽不在同一个线程，信号将排队，等待事件循环的处理，效果等同于Qt::QueuedConnection。

信号和槽机制增强了对象间通信的灵活性，然而这也损失了一些性能。与回调函数相比较，信号和槽机制有些慢。 通常， 通过传递一个信号来调用槽函数将会比直接调用非虚函数慢10倍。原因主要有：

* 需要定位接收信号的对象；
* 安全地遍历所有的关联（比如，一个信号关联到多个槽的情况）;
* 编组（marshal）/解组（unmarshal）传递的参数；
* 多线程的时候，信号可能需要排队等待。

与创建堆对象的new操作以及删除堆对象的delete操作相比较，信号和槽的代价只是它们很少的一部分。信号和槽机制导致的这点性能损耗，对实时应用程序是可以忽略的。与信号和槽提供的灵活性和简便性相比，这点性能的损失也是值得的。
